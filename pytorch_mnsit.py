# -*- coding: utf-8 -*-
"""Pytorch MNSIT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Tll11JEonzfDXiGolVOR6eVMweoqCwn
"""

!pip install torch
!pip install torch-vision

!pip install --upgrade torchvision

import torch
import torchvision.transforms as transforms
import torchvision.datasets as datasets

train  =  datasets.MNIST("", train = True, download = True,
                         transform= transforms.Compose(
                             [transforms.ToTensor()])
                         )
test  =  datasets.MNIST("", train = torch._fake_quantize_learnable_per_tensor_affine, download = True,
                         transform= transforms.Compose(
                             [transforms.ToTensor()])
                         )

trainset = torch.utils.data.DataLoader( train, batch_size = 32, shuffle = True )
testset = torch.utils.data.DataLoader( test, batch_size = 32, shuffle = True )

for singlebatchData in trainset:
  print(singlebatchData)
  break

"""Remember the dataloaded format is a big tensor of 2 tensors such that,

1st tensor contains all images of current batch(2d tensors of images specifically)

2nd tensor contains labels of all images in 1d tensor format
"""

# Hence to find the 1st image in a batch and its label along with it use following

print("The image is :" ,singlebatchData[0][0])

print("The label : " ,singlebatchData[1][0])

# 1st index points whether its image tensor or label tensor
# 2nd index points the position of current image/label in the batch

"""Note that in our Problem, The image tensor itself is the input features (X)
and the label itself in the target varible(y)


"""

X = singlebatchData[0][0]
y = singlebatchData[1][0]

"""We can display the image in matplot and verify it."""

import matplotlib.pyplot as plt

plt.imshow(X)

"""This happende because the channel for grayscale is 1, which is unnecessary but PyTorch needs it.

Hence we need to either : transform the shape of while printing the image
OR just assume its a array of single element consisting of 2d matrix. Hence access the image by accessing the only element of this array X[0]
"""

# For Transforming it to correct shape use view()

X2 = X.view((28,28))
plt.imshow(X2)

# For accessing it assuming it as single element array

plt.imshow(X[0])

from torch import nn
import torch.nn.functional as F


class myNet(nn.Module):
  def __init__(self):
    super().__init__()
    self.fc1 = nn.Linear( 28*28, 64 )
    self.fc2 = nn.Linear( 64, 64 )
    self.fc3 = nn.Linear( 64, 64 )
    self.fc4 = nn.Linear( 64, 10 )
  def forward(self, x ):
    x = F.relu( self.fc1(x) )
    x = F.relu( self.fc2(x) )
    x = F.relu( self.fc3(x) )
    x = F.log_softmax( self.fc4(x), dim =1)
    return x

model = myNet()

print(model)

# Verify the working
X ,y = singlebatchData

#print(X)

#print(X.view(-1,28*28).shape)

#print(y)

#print(X.shape)

ysamp = model(X.view((-1,28*28)))
print(ysamp[0])

image = X[0]

plt.imshow(image.view((28,28)))

"""Training :"""

import numpy as np

epochs = 20
lr = 0.01

val_loss_min = np.inf

for ep in range(epochs):

  lossFn = torch.nn.NLLLoss() #negative log likelyhood loss, used when the output activation is log-probability based.

  opt = torch.optim.Adam( model.parameters(), lr)

  model.train()

  for singlebatchData in trainset:

    X, ytrain = singlebatchData

    opt.zero_grad()

    ypred = model(X.view(-1,28*28))
    loss = lossFn(ypred, ytrain)

    loss.backward()

    opt.step()

  with torch.no_grad():
    model.eval()

    for singlebatchData in testset:

      Xtest, ytest = singlebatchData

      ypred = model(Xtest.view(-1,28*28))

      val_loss = lossFn(ypred, ytest)

      if val_loss <= val_loss_min:

        torch.save(model.state_dict(), './state_dict.pt')

        print( f'validation loss decreased. {val_loss_min} --> {val_loss}')

        val_loss_min = val_loss
    print(f' Training loss : {loss} , validation_loss : {val_loss} , Best Valid Loss : {val_loss_min} ')

for t in testset:
  X, y =t
  break

plt.imshow(X[6].view((28,28)))

print("The label associted is",y.numpy()[6])





